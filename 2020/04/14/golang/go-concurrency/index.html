<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/articles/img/favicon.png"><title>Golang Concurrency Pattern</title><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/articles/atom.xml" title="Articles" type="application/atom+xml">
</head><body>　　<div class="inner"><h2>Golang Concurrency Pattern</h2><p>注意：以下所说的线程、进程、协程都是指一个东西：<code>goroutine</code></p>
<h2 id="5-种模式"><a href="#5-种模式" class="headerlink" title="5 种模式"></a>5 种模式</h2><ul>
<li>最大输入的管道</li>
<li>任务分解多个协程，结果彼此无关</li>
<li>线程安全的数据结构，不需要锁</li>
<li>三种方法，将任务分成固定多个协程，并在最后合并结果</li>
<li>创建进程依赖的数量的协程，并在最后合并结果</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>因为没有完成信号，所有协程都没有退出，即使任务已经完成</li>
<li>阻塞的线程想要获得其它正在阻塞的线程的锁</li>
</ul>
<p>使用 done 通道报告结果。</p>
<p>使用 sync.WaitGroup ，但当其它线程正在阻塞，而 sync.WaitGroup.Wait() 在主进程被调用时，就会出现死锁。</p>
<p>使用 Channel 依然会导致死锁，比如</p>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>安全：bool, int, float64, string</p>
<p>不安全：</p>
<ul>
<li>引用类型，除非 1.互斥量 2.访问规则 3.不修改</li>
<li>定义了修改的接口类型</li>
</ul>
<p>没有缓冲区的通道会立即阻塞，直到有其它进程从中读取。缓冲区能够提高吞吐量。</p>
<p>发送端的进程关闭通道</p>
<p>单向通道表达程序思想</p>
<p>通道关闭</p>
<p>合理设置缓冲区大小和进程数量，尽可能将不必要的阻塞降低到最低</p>
<p>带有通道参数的函数，通常将目标通道放在前面，源通道放在后面。</p>
<p>双向通道才允许关闭</p>
<p>使用非阻塞 select，可通过 timeout 退出</p>
<p>线程安全的映射，能够被多个线程共享。只要按照 safemap/safemap.go 定义的 SafeMap 接口实现就行。</p>
<blockquote>
<p>可导出/不可导出的接口</p>
</blockquote>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul>
<li>对于从无缓冲 Channel 进行的接收，发生在对该 Channel 进行的发送完成之前</li>
<li>对于带缓冲的 Channel，对于 Channel 的第 K 个接收完成操作发生在第 K+C 个发送操作完成之前，其中 C 是 Channel 的缓存大小</li>
</ul>
<hr><p><span>↶ </span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>